// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    from_account_id,
    to_account_id,
    type_code,
    amount,
    currency_code,
    exchange_rate,
    status_code,
    description,
    reference_number,
    transaction_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number
`

type CreateTransactionParams struct {
	FromAccountID   sql.NullInt32  `json:"from_account_id"`
	ToAccountID     sql.NullInt32  `json:"to_account_id"`
	TypeCode        string         `json:"type_code"`
	Amount          pgtype.Numeric `json:"amount"`
	CurrencyCode    string         `json:"currency_code"`
	ExchangeRate    pgtype.Numeric `json:"exchange_rate"`
	StatusCode      string         `json:"status_code"`
	Description     sql.NullString `json:"description"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	TransactionDate time.Time      `json:"transaction_date"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.TypeCode,
		arg.Amount,
		arg.CurrencyCode,
		arg.ExchangeRate,
		arg.StatusCode,
		arg.Description,
		arg.ReferenceNumber,
		arg.TransactionDate,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.IsCompleted,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransactionNumber,
	)
	return i, err
}

const deleteAccountTransactions = `-- name: DeleteAccountTransactions :exec
DELETE FROM transactions
WHERE from_account_id = $1 OR to_account_id = $1
`

func (q *Queries) DeleteAccountTransactions(ctx context.Context, fromAccountID sql.NullInt32) error {
	_, err := q.db.Exec(ctx, deleteAccountTransactions, fromAccountID)
	return err
}

const deleteTransaction = `-- name: DeleteTransaction :exec
DELETE FROM transactions 
WHERE transaction_number = $1
`

func (q *Queries) DeleteTransaction(ctx context.Context, transactionNumber uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteTransaction, transactionNumber)
	return err
}

const deleteTransactionsByDateRange = `-- name: DeleteTransactionsByDateRange :exec
DELETE FROM transactions 
WHERE transaction_date BETWEEN $1 AND $2
`

type DeleteTransactionsByDateRangeParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) DeleteTransactionsByDateRange(ctx context.Context, arg DeleteTransactionsByDateRangeParams) error {
	_, err := q.db.Exec(ctx, deleteTransactionsByDateRange, arg.StartDate, arg.EndDate)
	return err
}

const deleteTransactionsByStatus = `-- name: DeleteTransactionsByStatus :exec
DELETE FROM transactions 
WHERE status_code = $1
`

func (q *Queries) DeleteTransactionsByStatus(ctx context.Context, statusCode string) error {
	_, err := q.db.Exec(ctx, deleteTransactionsByStatus, statusCode)
	return err
}

const getTransaction = `-- name: GetTransaction :one
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number FROM transactions
WHERE transaction_id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, transactionID int32) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.IsCompleted,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransactionNumber,
	)
	return i, err
}

const getTransactionBalance = `-- name: GetTransactionBalance :one
SELECT COALESCE(SUM(amount), 0) as balance
FROM transactions
WHERE from_account_id = $1 OR to_account_id = $1
`

func (q *Queries) GetTransactionBalance(ctx context.Context, fromAccountID sql.NullInt32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getTransactionBalance, fromAccountID)
	var balance interface{}
	err := row.Scan(&balance)
	return balance, err
}

const getTransactionByReference = `-- name: GetTransactionByReference :one
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number
FROM transactions
WHERE reference_number = $1
`

func (q *Queries) GetTransactionByReference(ctx context.Context, referenceNumber sql.NullString) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransactionByReference, referenceNumber)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.IsCompleted,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransactionNumber,
	)
	return i, err
}

const getTransactionStatement = `-- name: GetTransactionStatement :many
SELECT transaction_id, from_account_id, to_account_id, 
        amount, currency_code, status_code, description,
        transaction_date
FROM transactions
WHERE (from_account_id = $1 OR to_account_id = $1)
    AND transaction_date BETWEEN $2 AND $3
ORDER BY transaction_date DESC
`

type GetTransactionStatementParams struct {
	FromAccountID     sql.NullInt32 `json:"from_account_id"`
	TransactionDate   time.Time     `json:"transaction_date"`
	TransactionDate_2 time.Time     `json:"transaction_date_2"`
}

type GetTransactionStatementRow struct {
	TransactionID   int32          `json:"transaction_id"`
	FromAccountID   sql.NullInt32  `json:"from_account_id"`
	ToAccountID     sql.NullInt32  `json:"to_account_id"`
	Amount          pgtype.Numeric `json:"amount"`
	CurrencyCode    string         `json:"currency_code"`
	StatusCode      string         `json:"status_code"`
	Description     sql.NullString `json:"description"`
	TransactionDate time.Time      `json:"transaction_date"`
}

func (q *Queries) GetTransactionStatement(ctx context.Context, arg GetTransactionStatementParams) ([]GetTransactionStatementRow, error) {
	rows, err := q.db.Query(ctx, getTransactionStatement, arg.FromAccountID, arg.TransactionDate, arg.TransactionDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetTransactionStatementRow{}
	for rows.Next() {
		var i GetTransactionStatementRow
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.Amount,
			&i.CurrencyCode,
			&i.StatusCode,
			&i.Description,
			&i.TransactionDate,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number FROM transactions
WHERE transaction_date BETWEEN $1 AND $2
ORDER BY transaction_date DESC
`

type GetTransactionsByDateRangeParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.IsCompleted,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTransactionsByStatus = `-- name: GetTransactionsByStatus :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number
FROM transactions
WHERE status_code = $1
ORDER BY transaction_date DESC
`

func (q *Queries) GetTransactionsByStatus(ctx context.Context, statusCode string) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByStatus, statusCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.IsCompleted,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAccountTransactions = `-- name: ListAccountTransactions :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number
FROM transactions
WHERE from_account_id = $1 OR to_account_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListAccountTransactionsParams struct {
	FromAccountID sql.NullInt32 `json:"from_account_id"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListAccountTransactions(ctx context.Context, arg ListAccountTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listAccountTransactions, arg.FromAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.IsCompleted,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number FROM transactions
WHERE from_account_id = $1 OR to_account_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByAccountParams struct {
	FromAccountID sql.NullInt32 `json:"from_account_id"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, arg ListTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccount, arg.FromAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.IsCompleted,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.TransactionNumber,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET status_code = $2
WHERE transaction_id = $1
RETURNING transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, is_completed, description, reference_number, transaction_date, created_at, updated_at, transaction_number
`

type UpdateTransactionStatusParams struct {
	TransactionID int32  `json:"transaction_id"`
	StatusCode    string `json:"status_code"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.TransactionID, arg.StatusCode)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.IsCompleted,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.TransactionNumber,
	)
	return i, err
}
