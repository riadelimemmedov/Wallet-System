// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    from_account_id,
    to_account_id,
    type_code,
    amount,
    currency_code,
    exchange_rate,
    status_code,
    description,
    reference_number,
    transaction_date
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
) RETURNING transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, description, reference_number, transaction_date, created_at, updated_at
`

type CreateTransactionParams struct {
	FromAccountID   sql.NullInt32  `json:"from_account_id"`
	ToAccountID     sql.NullInt32  `json:"to_account_id"`
	TypeCode        string         `json:"type_code"`
	Amount          pgtype.Numeric `json:"amount"`
	CurrencyCode    string         `json:"currency_code"`
	ExchangeRate    pgtype.Numeric `json:"exchange_rate"`
	StatusCode      string         `json:"status_code"`
	Description     sql.NullString `json:"description"`
	ReferenceNumber sql.NullString `json:"reference_number"`
	TransactionDate time.Time      `json:"transaction_date"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.FromAccountID,
		arg.ToAccountID,
		arg.TypeCode,
		arg.Amount,
		arg.CurrencyCode,
		arg.ExchangeRate,
		arg.StatusCode,
		arg.Description,
		arg.ReferenceNumber,
		arg.TransactionDate,
	)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, description, reference_number, transaction_date, created_at, updated_at FROM transactions
WHERE transaction_id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, transactionID int32) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, transactionID)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTransactionsByDateRange = `-- name: GetTransactionsByDateRange :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, description, reference_number, transaction_date, created_at, updated_at FROM transactions
WHERE transaction_date BETWEEN $1 AND $2
ORDER BY transaction_date DESC
`

type GetTransactionsByDateRangeParams struct {
	StartDate time.Time `json:"start_date"`
	EndDate   time.Time `json:"end_date"`
}

func (q *Queries) GetTransactionsByDateRange(ctx context.Context, arg GetTransactionsByDateRangeParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, getTransactionsByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTransactionsByAccount = `-- name: ListTransactionsByAccount :many
SELECT transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, description, reference_number, transaction_date, created_at, updated_at FROM transactions
WHERE from_account_id = $1 OR to_account_id = $1
ORDER BY transaction_date DESC
LIMIT $2 OFFSET $3
`

type ListTransactionsByAccountParams struct {
	FromAccountID sql.NullInt32 `json:"from_account_id"`
	Limit         int32         `json:"limit"`
	Offset        int32         `json:"offset"`
}

func (q *Queries) ListTransactionsByAccount(ctx context.Context, arg ListTransactionsByAccountParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactionsByAccount, arg.FromAccountID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.TransactionID,
			&i.FromAccountID,
			&i.ToAccountID,
			&i.TypeCode,
			&i.Amount,
			&i.CurrencyCode,
			&i.ExchangeRate,
			&i.StatusCode,
			&i.Description,
			&i.ReferenceNumber,
			&i.TransactionDate,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transactions
SET status_code = $2
WHERE transaction_id = $1
RETURNING transaction_id, from_account_id, to_account_id, type_code, amount, currency_code, exchange_rate, status_code, description, reference_number, transaction_date, created_at, updated_at
`

type UpdateTransactionStatusParams struct {
	TransactionID int32  `json:"transaction_id"`
	StatusCode    string `json:"status_code"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.TransactionID, arg.StatusCode)
	var i Transaction
	err := row.Scan(
		&i.TransactionID,
		&i.FromAccountID,
		&i.ToAccountID,
		&i.TypeCode,
		&i.Amount,
		&i.CurrencyCode,
		&i.ExchangeRate,
		&i.StatusCode,
		&i.Description,
		&i.ReferenceNumber,
		&i.TransactionDate,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
