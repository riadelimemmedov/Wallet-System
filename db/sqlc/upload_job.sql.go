// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: upload_job.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/jackc/pgtype"
)

const countUserUploads = `-- name: CountUserUploads :one
SELECT COUNT(*) FROM upload_jobs
WHERE user_id = $1 AND status = 'COMPLETED'
`

func (q *Queries) CountUserUploads(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUserUploads, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFileMetadata = `-- name: CreateFileMetadata :one
INSERT INTO file_metadata (
    id,
    s3_url,
    checksum,
    mime_type,
    width,
    height,
    additional_data,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING id, upload_jobs_id, s3_url, checksum, mime_type, width, height, additional_data, created_at, updated_at
`

type CreateFileMetadataParams struct {
	ID             int32         `json:"id"`
	S3Url          string        `json:"s3_url"`
	Checksum       string        `json:"checksum"`
	MimeType       string        `json:"mime_type"`
	Width          sql.NullInt32 `json:"width"`
	Height         sql.NullInt32 `json:"height"`
	AdditionalData pgtype.JSONB  `json:"additional_data"`
	CreatedAt      time.Time     `json:"created_at"`
	UpdatedAt      time.Time     `json:"updated_at"`
}

func (q *Queries) CreateFileMetadata(ctx context.Context, arg CreateFileMetadataParams) (FileMetadatum, error) {
	row := q.db.QueryRow(ctx, createFileMetadata,
		arg.ID,
		arg.S3Url,
		arg.Checksum,
		arg.MimeType,
		arg.Width,
		arg.Height,
		arg.AdditionalData,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i FileMetadatum
	err := row.Scan(
		&i.ID,
		&i.UploadJobsID,
		&i.S3Url,
		&i.Checksum,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.AdditionalData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUploadJob = `-- name: CreateUploadJob :one
INSERT INTO upload_jobs (
    id,
    file_name,
    file_size,
    content_type,
    temp_path,
    target_path,
    user_id,
    status,
    error_message,
    created_at,
    updated_at
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at
`

type CreateUploadJobParams struct {
	ID           string         `json:"id"`
	FileName     string         `json:"file_name"`
	FileSize     int64          `json:"file_size"`
	ContentType  string         `json:"content_type"`
	TempPath     string         `json:"temp_path"`
	TargetPath   string         `json:"target_path"`
	UserID       int32          `json:"user_id"`
	Status       UploadStatus   `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	CreatedAt    time.Time      `json:"created_at"`
	UpdatedAt    time.Time      `json:"updated_at"`
}

func (q *Queries) CreateUploadJob(ctx context.Context, arg CreateUploadJobParams) (UploadJob, error) {
	row := q.db.QueryRow(ctx, createUploadJob,
		arg.ID,
		arg.FileName,
		arg.FileSize,
		arg.ContentType,
		arg.TempPath,
		arg.TargetPath,
		arg.UserID,
		arg.Status,
		arg.ErrorMessage,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i UploadJob
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FileSize,
		&i.ContentType,
		&i.TempPath,
		&i.TargetPath,
		&i.UserID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const deleteUploadJob = `-- name: DeleteUploadJob :exec
DELETE FROM upload_jobs
WHERE id = $1
`

func (q *Queries) DeleteUploadJob(ctx context.Context, id string) error {
	_, err := q.db.Exec(ctx, deleteUploadJob, id)
	return err
}

const getFileMetadata = `-- name: GetFileMetadata :one
SELECT id, upload_jobs_id, s3_url, checksum, mime_type, width, height, additional_data, created_at, updated_at FROM file_metadata
WHERE id = $1
`

func (q *Queries) GetFileMetadata(ctx context.Context, id int32) (FileMetadatum, error) {
	row := q.db.QueryRow(ctx, getFileMetadata, id)
	var i FileMetadatum
	err := row.Scan(
		&i.ID,
		&i.UploadJobsID,
		&i.S3Url,
		&i.Checksum,
		&i.MimeType,
		&i.Width,
		&i.Height,
		&i.AdditionalData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUploadJob = `-- name: GetUploadJob :one
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE id = $1
`

func (q *Queries) GetUploadJob(ctx context.Context, id int64) (UploadJob, error) {
	row := q.db.QueryRow(ctx, getUploadJob, id)
	var i UploadJob
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FileSize,
		&i.ContentType,
		&i.TempPath,
		&i.TargetPath,
		&i.UserID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listCompletedUploadJobs = `-- name: ListCompletedUploadJobs :many
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE status = 'COMPLETED'
ORDER BY completed_at DESC
LIMIT $1
`

func (q *Queries) ListCompletedUploadJobs(ctx context.Context, limit int32) ([]UploadJob, error) {
	rows, err := q.db.Query(ctx, listCompletedUploadJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadJob{}
	for rows.Next() {
		var i UploadJob
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
			&i.TempPath,
			&i.TargetPath,
			&i.UserID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFailedUploadJobs = `-- name: ListFailedUploadJobs :many
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE status = 'FAILED'
ORDER BY updated_at DESC
LIMIT $1
`

func (q *Queries) ListFailedUploadJobs(ctx context.Context, limit int32) ([]UploadJob, error) {
	rows, err := q.db.Query(ctx, listFailedUploadJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadJob{}
	for rows.Next() {
		var i UploadJob
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
			&i.TempPath,
			&i.TargetPath,
			&i.UserID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFilesByMimeType = `-- name: ListFilesByMimeType :many
SELECT fm.id, fm.upload_jobs_id, fm.s3_url, fm.checksum, fm.mime_type, fm.width, fm.height, fm.additional_data, fm.created_at, fm.updated_at
FROM file_metadata fm
JOIN upload_jobs uj ON fm.upload_jobs_id = uj.id
WHERE fm.mime_type LIKE $1 || '%'
AND uj.user_id = $2
ORDER BY fm.created_at DESC
LIMIT $3 OFFSET $4
`

type ListFilesByMimeTypeParams struct {
	Column1 sql.NullString `json:"column_1"`
	UserID  int32          `json:"user_id"`
	Limit   int32          `json:"limit"`
	Offset  int32          `json:"offset"`
}

func (q *Queries) ListFilesByMimeType(ctx context.Context, arg ListFilesByMimeTypeParams) ([]FileMetadatum, error) {
	rows, err := q.db.Query(ctx, listFilesByMimeType,
		arg.Column1,
		arg.UserID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []FileMetadatum{}
	for rows.Next() {
		var i FileMetadatum
		if err := rows.Scan(
			&i.ID,
			&i.UploadJobsID,
			&i.S3Url,
			&i.Checksum,
			&i.MimeType,
			&i.Width,
			&i.Height,
			&i.AdditionalData,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPendingUploadJobs = `-- name: ListPendingUploadJobs :many
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE status = 'PENDING'
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListPendingUploadJobs(ctx context.Context, limit int32) ([]UploadJob, error) {
	rows, err := q.db.Query(ctx, listPendingUploadJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadJob{}
	for rows.Next() {
		var i UploadJob
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
			&i.TempPath,
			&i.TargetPath,
			&i.UserID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProcessingUploadJobs = `-- name: ListProcessingUploadJobs :many
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE status = 'PROCESSING'
ORDER BY created_at DESC
LIMIT $1
`

func (q *Queries) ListProcessingUploadJobs(ctx context.Context, limit int32) ([]UploadJob, error) {
	rows, err := q.db.Query(ctx, listProcessingUploadJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadJob{}
	for rows.Next() {
		var i UploadJob
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
			&i.TempPath,
			&i.TargetPath,
			&i.UserID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUseUrploadJobs = `-- name: ListUseUrploadJobs :many
SELECT id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at FROM upload_jobs
WHERE user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListUseUrploadJobsParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListUseUrploadJobs(ctx context.Context, arg ListUseUrploadJobsParams) ([]UploadJob, error) {
	rows, err := q.db.Query(ctx, listUseUrploadJobs, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []UploadJob{}
	for rows.Next() {
		var i UploadJob
		if err := rows.Scan(
			&i.ID,
			&i.FileName,
			&i.FileSize,
			&i.ContentType,
			&i.TempPath,
			&i.TargetPath,
			&i.UserID,
			&i.Status,
			&i.ErrorMessage,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUploadJobStatus = `-- name: UpdateUploadJobStatus :one
UPDATE upload_jobs SET 
    status = $1,
    error_message = $2,
    updated_at = $3,
    completed_at = CASE WHEN $1 IN ('COMPLETED', 'FAILED') THEN $4 ELSE completed_at END
WHERE id = $5
RETURNING id, file_name, file_size, content_type, temp_path, target_path, user_id, status, error_message, created_at, updated_at, completed_at
`

type UpdateUploadJobStatusParams struct {
	Status       UploadStatus   `json:"status"`
	ErrorMessage sql.NullString `json:"error_message"`
	UpdatedAt    time.Time      `json:"updated_at"`
	CompletedAt  sql.NullTime   `json:"completed_at"`
	ID           string         `json:"id"`
}

func (q *Queries) UpdateUploadJobStatus(ctx context.Context, arg UpdateUploadJobStatusParams) (UploadJob, error) {
	row := q.db.QueryRow(ctx, updateUploadJobStatus,
		arg.Status,
		arg.ErrorMessage,
		arg.UpdatedAt,
		arg.CompletedAt,
		arg.ID,
	)
	var i UploadJob
	err := row.Scan(
		&i.ID,
		&i.FileName,
		&i.FileSize,
		&i.ContentType,
		&i.TempPath,
		&i.TargetPath,
		&i.UserID,
		&i.Status,
		&i.ErrorMessage,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}
